"""Report generation utilities."""

import json
from datetime import datetime
from pathlib import Path
from typing import List, Dict, Any, Optional


def generate_update_report(
    updates_available: List[Dict[str, Any]],
    up_to_date: List[Dict[str, Any]],
    errors: List[Dict[str, Any]],
    report_path: Path,
    include_up_to_date: bool = False
) -> None:
    """Generate a Markdown report for model updates.
    
    Args:
        updates_available: List of models with updates available
        up_to_date: List of models that are up to date
        errors: List of models that had errors during checking
        report_path: Path to save the report
        include_up_to_date: Whether to include up-to-date models in report
    """
    lines = []
    
    # Header
    lines.append("# AI Model Update Report")
    lines.append("")
    lines.append(f"**Generated:** {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    lines.append("")
    
    # Summary
    total_checked = len(updates_available) + len(up_to_date) + len(errors)
    lines.append("## Summary")
    lines.append("")
    lines.append(f"- **Total models checked:** {total_checked}")
    lines.append(f"- **Updates available:** {len(updates_available)}")
    lines.append(f"- **Up to date:** {len(up_to_date)}")
    lines.append(f"- **Errors:** {len(errors)}")
    lines.append("")
    
    # Models with updates available
    if updates_available:
        lines.append("## ðŸ”„ Models with Updates Available")
        lines.append("")
        
        for update in updates_available:
            lines.extend(_format_model_update(update))
            lines.append("")
    
    # Up-to-date models (if requested)
    if include_up_to_date and up_to_date:
        lines.append("## âœ… Models Up to Date")
        lines.append("")
        
        for model in up_to_date:
            lines.extend(_format_model_current(model))
            lines.append("")
    
    # Errors
    if errors:
        lines.append("## âŒ Errors Encountered")
        lines.append("")
        
        for error in errors:
            lines.append(f"- **{error['file'].name}:** {error['error']}")
        
        lines.append("")
    
    # Footer
    lines.append("---")
    lines.append("*Generated by AI Model CLI*")
    
    # Write report
    report_content = "\n".join(lines)
    with open(report_path, 'w', encoding='utf-8') as f:
        f.write(report_content)


def _format_model_update(update: Dict[str, Any]) -> List[str]:
    """Format a model with available updates for the report.
    
    Args:
        update: Update information dictionary
        
    Returns:
        List of formatted lines
    """
    lines = []
    
    model_name = update["model_name"]
    model_id = update["model_id"]
    current_version = update["current_version"]
    latest_version = update["latest_version"]
    file_path = update["file_path"]
    
    # Model header with CivitAI link
    civitai_url = f"https://civitai.com/models/{model_id}"
    lines.append(f"### [{model_name}]({civitai_url})")
    lines.append("")
    
    # Add preview image if available
    preview_images = _get_preview_images(latest_version)
    if preview_images:
        lines.append("#### Preview")
        lines.append("")
        # Create a horizontal layout for multiple images
        if len(preview_images) > 1:
            lines.append('<div style="display: flex; flex-wrap: wrap; gap: 8px;">')
            for i, img_url in enumerate(preview_images[:3]):  # Show up to 3 images
                lines.append(f'  <img src="{img_url}" alt="Preview {i+1}" width="256" style="max-width: 256px; height: auto;" />')
            lines.append('</div>')
        else:
            lines.append(f'<img src="{preview_images[0]}" alt="Preview" width="256" style="max-width: 256px; height: auto;" />')
        lines.append("")
    
    # Basic information
    lines.append("| Property | Value |")
    lines.append("|----------|-------|")
    lines.append(f"| **Model ID** | [{model_id}]({civitai_url}) |")
    lines.append(f"| **Local File** | `{file_path.name}` |")
    lines.append(f"| **Full Path** | `{str(file_path)}` |")
    
    # Version information
    current_name = "Unknown"
    current_published = "Unknown"
    if current_version:
        current_name = current_version.get("name", "Unknown")
        current_published = current_version.get("publishedAt", "Unknown")
        if current_published != "Unknown" and current_published:
            try:
                dt = datetime.fromisoformat(current_published.replace('Z', '+00:00'))
                current_published = dt.strftime("%Y-%m-%d")
            except:
                current_published = current_published.split('T')[0] if 'T' in current_published else current_published
    
    latest_name = latest_version.get("name", "Unknown")
    latest_published = latest_version.get("publishedAt", "Unknown")
    if latest_published != "Unknown" and latest_published:
        try:
            dt = datetime.fromisoformat(latest_published.replace('Z', '+00:00'))
            latest_published = dt.strftime("%Y-%m-%d")
        except:
            latest_published = latest_published.split('T')[0] if 'T' in latest_published else latest_published
    
    lines.append(f"| **Current Version** | {current_name} ({current_published}) |")
    lines.append(f"| **Latest Version** | {latest_name} ({latest_published}) |")
    
    # Additional information from latest version
    base_model = latest_version.get("baseModel", "Unknown")
    if base_model != "Unknown":
        lines.append(f"| **Base Model** | {base_model} |")
    
    # File information
    files = latest_version.get("files", [])
    if files:
        primary_file = next((f for f in files if f.get('primary')), files[0])
        file_size = primary_file.get('sizeKB', 0)
        if file_size > 0:
            # Convert to human readable format
            size_str = _format_file_size(file_size * 1024)
            lines.append(f"| **File Size** | {size_str} |")
        
        file_format = primary_file.get('metadata', {}).get('format', 'Unknown')
        if file_format != "Unknown":
            lines.append(f"| **Format** | {file_format} |")
    
    # Download stats from latest version
    download_count = latest_version.get("stats", {}).get("downloadCount", 0)
    if download_count > 0:
        lines.append(f"| **Downloads** | {download_count:,} |")
    
    lines.append("")
    
    # Version-specific link
    latest_version_id = latest_version.get("id")
    if latest_version_id:
        version_url = f"{civitai_url}?modelVersionId={latest_version_id}"
        lines.append(f"ðŸ”— **Direct Version Link:** [{latest_name}]({version_url})")
        lines.append("")
    
    # Show available newer versions count
    newer_versions = update.get("newer_versions", [])
    if len(newer_versions) > 1:
        lines.append(f"ðŸ“ˆ **{len(newer_versions)} newer versions available**")
        lines.append("")
    
    return lines


def _format_model_current(model: Dict[str, Any]) -> List[str]:
    """Format a model that is up to date for the report.
    
    Args:
        model: Model information dictionary
        
    Returns:
        List of formatted lines
    """
    lines = []
    
    model_name = model["model_name"]
    model_id = model["model_id"]
    current_version = model["current_version"]
    file_path = model["file_path"]
    
    # Model header with CivitAI link
    civitai_url = f"https://civitai.com/models/{model_id}"
    lines.append(f"### [{model_name}]({civitai_url})")
    lines.append("")
    
    # Add preview image if available
    if current_version:
        preview_images = _get_preview_images(current_version)
        if preview_images:
            lines.append("#### Preview")
            lines.append("")
            # Show just one image for up-to-date models to keep report concise
            lines.append(f'<img src="{preview_images[0]}" alt="Preview" width="256" style="max-width: 256px; height: auto;" />')
            lines.append("")
    
    # Basic information
    current_name = "Unknown"
    current_published = "Unknown"
    if current_version:
        current_name = current_version.get("name", "Unknown")
        current_published = current_version.get("publishedAt", "Unknown")
        if current_published != "Unknown" and current_published:
            try:
                dt = datetime.fromisoformat(current_published.replace('Z', '+00:00'))
                current_published = dt.strftime("%Y-%m-%d")
            except:
                current_published = current_published.split('T')[0] if 'T' in current_published else current_published
    
    lines.append(f"- **Local File:** `{file_path.name}`")
    lines.append(f"- **Current Version:** {current_name} ({current_published})")
    lines.append(f"- **CivitAI Link:** [{model_id}]({civitai_url})")
    
    return lines


def _get_preview_images(version: Dict[str, Any]) -> List[str]:
    """Extract preview image URLs from version data.
    
    Args:
        version: Version data from CivitAI API
        
    Returns:
        List of preview image URLs
    """
    preview_urls = []
    
    # Get images from version
    images = version.get("images", [])
    for image in images:
        url = image.get("url")
        if url:
            # Use medium size for better loading performance
            # CivitAI supports width parameter for resizing
            if "?" in url:
                resized_url = f"{url}&width=512"
            else:
                resized_url = f"{url}?width=512"
            preview_urls.append(resized_url)
    
    return preview_urls


def _format_file_size(size_bytes: int) -> str:
    """Format file size in human readable format.
    
    Args:
        size_bytes: Size in bytes
        
    Returns:
        Formatted size string
    """
    for unit in ['B', 'KB', 'MB', 'GB', 'TB']:
        if size_bytes < 1024:
            return f"{size_bytes:.1f} {unit}"
        size_bytes /= 1024
    return f"{size_bytes:.1f} PB"